// WARNING: Please don't edit this file. It was generated by C++/WinRT v1.0.180821.2

#pragma once

#include "winrt/base.h"


static_assert(winrt::check_version(CPPWINRT_VERSION, "1.0.180821.2"), "Mismatched component and base headers.");
#include "winrt/Windows.Foundation.h"
#include "winrt/Windows.Foundation.Collections.h"
#include "winrt/impl/Windows.Perception.Spatial.2.h"
#include "winrt/impl/Microsoft.Azure.SpatialAnchors.2.h"

namespace winrt::impl {

template <typename D> com_array<hstring> consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::Identifiers() const
{
    com_array<hstring> value;
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->get_Identifiers(impl::put_size_abi(value), put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::Identifiers(array_view<hstring const> value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->put_Identifiers(value.size(), get_abi(value)));
}

template <typename D> bool consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::BypassCache() const
{
    bool value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->get_BypassCache(&value));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::BypassCache(bool value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->put_BypassCache(value));
}

template <typename D> Microsoft::Azure::SpatialAnchors::NearAnchorCriteria consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::NearAnchor() const
{
    Microsoft::Azure::SpatialAnchors::NearAnchorCriteria value{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->get_NearAnchor(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::NearAnchor(Microsoft::Azure::SpatialAnchors::NearAnchorCriteria const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->put_NearAnchor(get_abi(value)));
}

template <typename D> Microsoft::Azure::SpatialAnchors::AnchorDataCategory consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::RequestedCategories() const
{
    Microsoft::Azure::SpatialAnchors::AnchorDataCategory value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->get_RequestedCategories(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::RequestedCategories(Microsoft::Azure::SpatialAnchors::AnchorDataCategory const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->put_RequestedCategories(get_abi(value)));
}

template <typename D> Microsoft::Azure::SpatialAnchors::LocateStrategy consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::Strategy() const
{
    Microsoft::Azure::SpatialAnchors::LocateStrategy value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->get_Strategy(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::Strategy(Microsoft::Azure::SpatialAnchors::LocateStrategy const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->put_Strategy(get_abi(value)));
}

template <typename D> Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor consume_Microsoft_Azure_SpatialAnchors_IAnchorLocatedEventArgs<D>::Anchor() const
{
    Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor value{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs)->get_Anchor(put_abi(value)));
    return value;
}

template <typename D> hstring consume_Microsoft_Azure_SpatialAnchors_IAnchorLocatedEventArgs<D>::Identifier() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs)->get_Identifier(put_abi(value)));
    return value;
}

template <typename D> Microsoft::Azure::SpatialAnchors::LocateAnchorStatus consume_Microsoft_Azure_SpatialAnchors_IAnchorLocatedEventArgs<D>::Status() const
{
    Microsoft::Azure::SpatialAnchors::LocateAnchorStatus value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs)->get_Status(put_abi(value)));
    return value;
}

template <typename D> Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher consume_Microsoft_Azure_SpatialAnchors_IAnchorLocatedEventArgs<D>::Watcher() const
{
    Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher value{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs)->get_Watcher(put_abi(value)));
    return value;
}

template <typename D> Windows::Perception::Spatial::SpatialAnchor consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor<D>::LocalAnchor() const
{
    Windows::Perception::Spatial::SpatialAnchor value{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor)->get_LocalAnchor(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor<D>::LocalAnchor(Windows::Perception::Spatial::SpatialAnchor const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor)->put_LocalAnchor(get_abi(value)));
}

template <typename D> Windows::Foundation::DateTime consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor<D>::Expiration() const
{
    Windows::Foundation::DateTime value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor)->get_Expiration(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor<D>::Expiration(Windows::Foundation::DateTime const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor)->put_Expiration(get_abi(value)));
}

template <typename D> hstring consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor<D>::Identifier() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor)->get_Identifier(put_abi(value)));
    return value;
}

template <typename D> Windows::Foundation::Collections::IMap<hstring, hstring> consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor<D>::AppProperties() const
{
    Windows::Foundation::Collections::IMap<hstring, hstring> value{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor)->get_AppProperties(put_abi(value)));
    return value;
}

template <typename D> hstring consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor<D>::VersionTag() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor)->get_VersionTag(put_abi(value)));
    return value;
}

template <typename D> Microsoft::Azure::SpatialAnchors::SessionConfiguration consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Configuration() const
{
    Microsoft::Azure::SpatialAnchors::SessionConfiguration value{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->get_Configuration(put_abi(value)));
    return value;
}

template <typename D> Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Diagnostics() const
{
    Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics value{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->get_Diagnostics(put_abi(value)));
    return value;
}

template <typename D> Microsoft::Azure::SpatialAnchors::SessionLogLevel consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::LogLevel() const
{
    Microsoft::Azure::SpatialAnchors::SessionLogLevel value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->get_LogLevel(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::LogLevel(Microsoft::Azure::SpatialAnchors::SessionLogLevel const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->put_LogLevel(get_abi(value)));
}

template <typename D> hstring consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::SessionId() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->get_SessionId(put_abi(value)));
    return value;
}

template <typename D> winrt::event_token consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::TokenRequired(Microsoft::Azure::SpatialAnchors::TokenRequiredDelegate const& handler) const
{
    winrt::event_token token{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->add_TokenRequired(get_abi(handler), put_abi(token)));
    return token;
}

template <typename D> typename consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::TokenRequired_revoker consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::TokenRequired(auto_revoke_t, Microsoft::Azure::SpatialAnchors::TokenRequiredDelegate const& handler) const
{
    return impl::make_event_revoker<D, TokenRequired_revoker>(this, TokenRequired(handler));
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::TokenRequired(winrt::event_token const& token) const noexcept
{
    WINRT_VERIFY_(0, WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->remove_TokenRequired(get_abi(token)));
}

template <typename D> winrt::event_token consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::AnchorLocated(Microsoft::Azure::SpatialAnchors::AnchorLocatedDelegate const& handler) const
{
    winrt::event_token token{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->add_AnchorLocated(get_abi(handler), put_abi(token)));
    return token;
}

template <typename D> typename consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::AnchorLocated_revoker consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::AnchorLocated(auto_revoke_t, Microsoft::Azure::SpatialAnchors::AnchorLocatedDelegate const& handler) const
{
    return impl::make_event_revoker<D, AnchorLocated_revoker>(this, AnchorLocated(handler));
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::AnchorLocated(winrt::event_token const& token) const noexcept
{
    WINRT_VERIFY_(0, WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->remove_AnchorLocated(get_abi(token)));
}

template <typename D> winrt::event_token consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::LocateAnchorsCompleted(Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedDelegate const& handler) const
{
    winrt::event_token token{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->add_LocateAnchorsCompleted(get_abi(handler), put_abi(token)));
    return token;
}

template <typename D> typename consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::LocateAnchorsCompleted_revoker consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::LocateAnchorsCompleted(auto_revoke_t, Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedDelegate const& handler) const
{
    return impl::make_event_revoker<D, LocateAnchorsCompleted_revoker>(this, LocateAnchorsCompleted(handler));
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::LocateAnchorsCompleted(winrt::event_token const& token) const noexcept
{
    WINRT_VERIFY_(0, WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->remove_LocateAnchorsCompleted(get_abi(token)));
}

template <typename D> winrt::event_token consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::SessionUpdated(Microsoft::Azure::SpatialAnchors::SessionUpdatedDelegate const& handler) const
{
    winrt::event_token token{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->add_SessionUpdated(get_abi(handler), put_abi(token)));
    return token;
}

template <typename D> typename consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::SessionUpdated_revoker consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::SessionUpdated(auto_revoke_t, Microsoft::Azure::SpatialAnchors::SessionUpdatedDelegate const& handler) const
{
    return impl::make_event_revoker<D, SessionUpdated_revoker>(this, SessionUpdated(handler));
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::SessionUpdated(winrt::event_token const& token) const noexcept
{
    WINRT_VERIFY_(0, WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->remove_SessionUpdated(get_abi(token)));
}

template <typename D> winrt::event_token consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Error(Microsoft::Azure::SpatialAnchors::SessionErrorDelegate const& handler) const
{
    winrt::event_token token{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->add_Error(get_abi(handler), put_abi(token)));
    return token;
}

template <typename D> typename consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Error_revoker consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Error(auto_revoke_t, Microsoft::Azure::SpatialAnchors::SessionErrorDelegate const& handler) const
{
    return impl::make_event_revoker<D, Error_revoker>(this, Error(handler));
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Error(winrt::event_token const& token) const noexcept
{
    WINRT_VERIFY_(0, WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->remove_Error(get_abi(token)));
}

template <typename D> winrt::event_token consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::OnLogDebug(Microsoft::Azure::SpatialAnchors::OnLogDebugDelegate const& handler) const
{
    winrt::event_token token{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->add_OnLogDebug(get_abi(handler), put_abi(token)));
    return token;
}

template <typename D> typename consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::OnLogDebug_revoker consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::OnLogDebug(auto_revoke_t, Microsoft::Azure::SpatialAnchors::OnLogDebugDelegate const& handler) const
{
    return impl::make_event_revoker<D, OnLogDebug_revoker>(this, OnLogDebug(handler));
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::OnLogDebug(winrt::event_token const& token) const noexcept
{
    WINRT_VERIFY_(0, WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->remove_OnLogDebug(get_abi(token)));
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Dispose() const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->Dispose());
}

template <typename D> Windows::Foundation::IAsyncOperation<hstring> consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::GetAccessTokenWithAuthenticationTokenAsync(param::hstring const& authenticationToken) const
{
    Windows::Foundation::IAsyncOperation<hstring> operation{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->GetAccessTokenWithAuthenticationTokenAsync(get_abi(authenticationToken), put_abi(operation)));
    return operation;
}

template <typename D> Windows::Foundation::IAsyncOperation<hstring> consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::GetAccessTokenWithAccountKeyAsync(param::hstring const& accountKey) const
{
    Windows::Foundation::IAsyncOperation<hstring> operation{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->GetAccessTokenWithAccountKeyAsync(get_abi(accountKey), put_abi(operation)));
    return operation;
}

template <typename D> Windows::Foundation::IAsyncAction consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::CreateAnchorAsync(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const& anchor) const
{
    Windows::Foundation::IAsyncAction operation{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->CreateAnchorAsync(get_abi(anchor), put_abi(operation)));
    return operation;
}

template <typename D> Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::CreateWatcher(Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria const& criteria) const
{
    Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher result{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->CreateWatcher(get_abi(criteria), put_abi(result)));
    return result;
}

template <typename D> Windows::Foundation::IAsyncOperation<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor> consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::GetAnchorPropertiesAsync(param::hstring const& identifier) const
{
    Windows::Foundation::IAsyncOperation<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor> operation{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->GetAnchorPropertiesAsync(get_abi(identifier), put_abi(operation)));
    return operation;
}

template <typename D> Windows::Foundation::Collections::IVectorView<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher> consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::GetActiveWatchers() const
{
    Windows::Foundation::Collections::IVectorView<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher> result{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->GetActiveWatchers(put_abi(result)));
    return result;
}

template <typename D> Windows::Foundation::IAsyncAction consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::RefreshAnchorPropertiesAsync(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const& anchor) const
{
    Windows::Foundation::IAsyncAction operation{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->RefreshAnchorPropertiesAsync(get_abi(anchor), put_abi(operation)));
    return operation;
}

template <typename D> Windows::Foundation::IAsyncAction consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::UpdateAnchorPropertiesAsync(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const& anchor) const
{
    Windows::Foundation::IAsyncAction operation{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->UpdateAnchorPropertiesAsync(get_abi(anchor), put_abi(operation)));
    return operation;
}

template <typename D> Windows::Foundation::IAsyncAction consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::DeleteAnchorAsync(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const& anchor) const
{
    Windows::Foundation::IAsyncAction operation{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->DeleteAnchorAsync(get_abi(anchor), put_abi(operation)));
    return operation;
}

template <typename D> Windows::Foundation::IAsyncOperation<Microsoft::Azure::SpatialAnchors::SessionStatus> consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::GetSessionStatusAsync() const
{
    Windows::Foundation::IAsyncOperation<Microsoft::Azure::SpatialAnchors::SessionStatus> operation{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->GetSessionStatusAsync(put_abi(operation)));
    return operation;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Start() const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->Start());
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Stop() const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->Stop());
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Reset() const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->Reset());
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDeferral<D>::Complete() const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDeferral)->Complete());
}

template <typename D> Microsoft::Azure::SpatialAnchors::SessionLogLevel consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::LogLevel() const
{
    Microsoft::Azure::SpatialAnchors::SessionLogLevel value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->get_LogLevel(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::LogLevel(Microsoft::Azure::SpatialAnchors::SessionLogLevel const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->put_LogLevel(get_abi(value)));
}

template <typename D> hstring consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::LogDirectory() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->get_LogDirectory(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::LogDirectory(param::hstring const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->put_LogDirectory(get_abi(value)));
}

template <typename D> int32_t consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::MaxDiskSizeInMB() const
{
    int32_t value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->get_MaxDiskSizeInMB(&value));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::MaxDiskSizeInMB(int32_t value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->put_MaxDiskSizeInMB(value));
}

template <typename D> bool consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::ImagesEnabled() const
{
    bool value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->get_ImagesEnabled(&value));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::ImagesEnabled(bool value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->put_ImagesEnabled(value));
}

template <typename D> Windows::Foundation::IAsyncOperation<hstring> consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::CreateManifestAsync(param::hstring const& description) const
{
    Windows::Foundation::IAsyncOperation<hstring> operation{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->CreateManifestAsync(get_abi(description), put_abi(operation)));
    return operation;
}

template <typename D> Windows::Foundation::IAsyncAction consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::SubmitManifestAsync(param::hstring const& manifestPath) const
{
    Windows::Foundation::IAsyncAction operation{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->SubmitManifestAsync(get_abi(manifestPath), put_abi(operation)));
    return operation;
}

template <typename D> int32_t consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorWatcher<D>::Identifier() const
{
    int32_t value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorWatcher)->get_Identifier(&value));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorWatcher<D>::Stop() const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorWatcher)->Stop());
}

template <typename D> bool consume_Microsoft_Azure_SpatialAnchors_ILocateAnchorsCompletedEventArgs<D>::Cancelled() const
{
    bool value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ILocateAnchorsCompletedEventArgs)->get_Cancelled(&value));
    return value;
}

template <typename D> Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher consume_Microsoft_Azure_SpatialAnchors_ILocateAnchorsCompletedEventArgs<D>::Watcher() const
{
    Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher value{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ILocateAnchorsCompletedEventArgs)->get_Watcher(put_abi(value)));
    return value;
}

template <typename D> Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor consume_Microsoft_Azure_SpatialAnchors_INearAnchorCriteria<D>::SourceAnchor() const
{
    Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor value{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::INearAnchorCriteria)->get_SourceAnchor(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_INearAnchorCriteria<D>::SourceAnchor(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::INearAnchorCriteria)->put_SourceAnchor(get_abi(value)));
}

template <typename D> float consume_Microsoft_Azure_SpatialAnchors_INearAnchorCriteria<D>::DistanceInMeters() const
{
    float value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::INearAnchorCriteria)->get_DistanceInMeters(&value));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_INearAnchorCriteria<D>::DistanceInMeters(float value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::INearAnchorCriteria)->put_DistanceInMeters(value));
}

template <typename D> int32_t consume_Microsoft_Azure_SpatialAnchors_INearAnchorCriteria<D>::MaxResultCount() const
{
    int32_t value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::INearAnchorCriteria)->get_MaxResultCount(&value));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_INearAnchorCriteria<D>::MaxResultCount(int32_t value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::INearAnchorCriteria)->put_MaxResultCount(value));
}

template <typename D> hstring consume_Microsoft_Azure_SpatialAnchors_IOnLogDebugEventArgs<D>::Message() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::IOnLogDebugEventArgs)->get_Message(put_abi(value)));
    return value;
}

template <typename D> hstring consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AccountDomain() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->get_AccountDomain(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AccountDomain(param::hstring const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->put_AccountDomain(get_abi(value)));
}

template <typename D> hstring consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AccountId() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->get_AccountId(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AccountId(param::hstring const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->put_AccountId(get_abi(value)));
}

template <typename D> hstring consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AuthenticationToken() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->get_AuthenticationToken(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AuthenticationToken(param::hstring const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->put_AuthenticationToken(get_abi(value)));
}

template <typename D> hstring consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AccountKey() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->get_AccountKey(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AccountKey(param::hstring const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->put_AccountKey(get_abi(value)));
}

template <typename D> hstring consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AccessToken() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->get_AccessToken(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AccessToken(param::hstring const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->put_AccessToken(get_abi(value)));
}

template <typename D> Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode consume_Microsoft_Azure_SpatialAnchors_ISessionErrorEventArgs<D>::ErrorCode() const
{
    Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs)->get_ErrorCode(put_abi(value)));
    return value;
}

template <typename D> hstring consume_Microsoft_Azure_SpatialAnchors_ISessionErrorEventArgs<D>::ErrorMessage() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs)->get_ErrorMessage(put_abi(value)));
    return value;
}

template <typename D> Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher consume_Microsoft_Azure_SpatialAnchors_ISessionErrorEventArgs<D>::Watcher() const
{
    Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher value{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs)->get_Watcher(put_abi(value)));
    return value;
}

template <typename D> float consume_Microsoft_Azure_SpatialAnchors_ISessionStatus<D>::ReadyForCreateProgress() const
{
    float value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionStatus)->get_ReadyForCreateProgress(&value));
    return value;
}

template <typename D> float consume_Microsoft_Azure_SpatialAnchors_ISessionStatus<D>::RecommendedForCreateProgress() const
{
    float value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionStatus)->get_RecommendedForCreateProgress(&value));
    return value;
}

template <typename D> int32_t consume_Microsoft_Azure_SpatialAnchors_ISessionStatus<D>::SessionCreateHash() const
{
    int32_t value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionStatus)->get_SessionCreateHash(&value));
    return value;
}

template <typename D> int32_t consume_Microsoft_Azure_SpatialAnchors_ISessionStatus<D>::SessionLocateHash() const
{
    int32_t value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionStatus)->get_SessionLocateHash(&value));
    return value;
}

template <typename D> Microsoft::Azure::SpatialAnchors::SessionUserFeedback consume_Microsoft_Azure_SpatialAnchors_ISessionStatus<D>::UserFeedback() const
{
    Microsoft::Azure::SpatialAnchors::SessionUserFeedback value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionStatus)->get_UserFeedback(put_abi(value)));
    return value;
}

template <typename D> Microsoft::Azure::SpatialAnchors::SessionStatus consume_Microsoft_Azure_SpatialAnchors_ISessionUpdatedEventArgs<D>::Status() const
{
    Microsoft::Azure::SpatialAnchors::SessionStatus value{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISessionUpdatedEventArgs)->get_Status(put_abi(value)));
    return value;
}

template <typename D> Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria consume_Microsoft_Azure_SpatialAnchors_ISpatialAnchorsFactory<D>::CreateAnchorLocateCriteria() const
{
    Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria result{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISpatialAnchorsFactory)->CreateAnchorLocateCriteria(put_abi(result)));
    return result;
}

template <typename D> Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor consume_Microsoft_Azure_SpatialAnchors_ISpatialAnchorsFactory<D>::CreateCloudSpatialAnchor() const
{
    Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor result{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISpatialAnchorsFactory)->CreateCloudSpatialAnchor(put_abi(result)));
    return result;
}

template <typename D> Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSession consume_Microsoft_Azure_SpatialAnchors_ISpatialAnchorsFactory<D>::CreateCloudSpatialAnchorSession() const
{
    Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSession result{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISpatialAnchorsFactory)->CreateCloudSpatialAnchorSession(put_abi(result)));
    return result;
}

template <typename D> Microsoft::Azure::SpatialAnchors::NearAnchorCriteria consume_Microsoft_Azure_SpatialAnchors_ISpatialAnchorsFactory<D>::CreateNearAnchorCriteria() const
{
    Microsoft::Azure::SpatialAnchors::NearAnchorCriteria result{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ISpatialAnchorsFactory)->CreateNearAnchorCriteria(put_abi(result)));
    return result;
}

template <typename D> hstring consume_Microsoft_Azure_SpatialAnchors_ITokenRequiredEventArgs<D>::AccessToken() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs)->get_AccessToken(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ITokenRequiredEventArgs<D>::AccessToken(param::hstring const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs)->put_AccessToken(get_abi(value)));
}

template <typename D> hstring consume_Microsoft_Azure_SpatialAnchors_ITokenRequiredEventArgs<D>::AuthenticationToken() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs)->get_AuthenticationToken(put_abi(value)));
    return value;
}

template <typename D> void consume_Microsoft_Azure_SpatialAnchors_ITokenRequiredEventArgs<D>::AuthenticationToken(param::hstring const& value) const
{
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs)->put_AuthenticationToken(get_abi(value)));
}

template <typename D> Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDeferral consume_Microsoft_Azure_SpatialAnchors_ITokenRequiredEventArgs<D>::GetDeferral() const
{
    Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDeferral result{ nullptr };
    check_hresult(WINRT_SHIM(Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs)->GetDeferral(put_abi(result)));
    return result;
}

template <> struct delegate<Microsoft::Azure::SpatialAnchors::AnchorLocatedDelegate>
{
    template <typename H>
    struct type : implements_delegate<Microsoft::Azure::SpatialAnchors::AnchorLocatedDelegate, H>
    {
        type(H&& handler) : implements_delegate<Microsoft::Azure::SpatialAnchors::AnchorLocatedDelegate, H>(std::forward<H>(handler)) {}

        int32_t WINRT_CALL Invoke(void* sender, void* args) noexcept final
        {
            try
            {
                (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Microsoft::Azure::SpatialAnchors::AnchorLocatedEventArgs const*>(&args));
                return 0;
            }
            catch (...)
            {
                return to_hresult();
            }
        }
    };
};

template <> struct delegate<Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedDelegate>
{
    template <typename H>
    struct type : implements_delegate<Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedDelegate, H>
    {
        type(H&& handler) : implements_delegate<Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedDelegate, H>(std::forward<H>(handler)) {}

        int32_t WINRT_CALL Invoke(void* sender, void* args) noexcept final
        {
            try
            {
                (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedEventArgs const*>(&args));
                return 0;
            }
            catch (...)
            {
                return to_hresult();
            }
        }
    };
};

template <> struct delegate<Microsoft::Azure::SpatialAnchors::OnLogDebugDelegate>
{
    template <typename H>
    struct type : implements_delegate<Microsoft::Azure::SpatialAnchors::OnLogDebugDelegate, H>
    {
        type(H&& handler) : implements_delegate<Microsoft::Azure::SpatialAnchors::OnLogDebugDelegate, H>(std::forward<H>(handler)) {}

        int32_t WINRT_CALL Invoke(void* sender, void* args) noexcept final
        {
            try
            {
                (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Microsoft::Azure::SpatialAnchors::OnLogDebugEventArgs const*>(&args));
                return 0;
            }
            catch (...)
            {
                return to_hresult();
            }
        }
    };
};

template <> struct delegate<Microsoft::Azure::SpatialAnchors::SessionErrorDelegate>
{
    template <typename H>
    struct type : implements_delegate<Microsoft::Azure::SpatialAnchors::SessionErrorDelegate, H>
    {
        type(H&& handler) : implements_delegate<Microsoft::Azure::SpatialAnchors::SessionErrorDelegate, H>(std::forward<H>(handler)) {}

        int32_t WINRT_CALL Invoke(void* sender, void* args) noexcept final
        {
            try
            {
                (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Microsoft::Azure::SpatialAnchors::SessionErrorEventArgs const*>(&args));
                return 0;
            }
            catch (...)
            {
                return to_hresult();
            }
        }
    };
};

template <> struct delegate<Microsoft::Azure::SpatialAnchors::SessionUpdatedDelegate>
{
    template <typename H>
    struct type : implements_delegate<Microsoft::Azure::SpatialAnchors::SessionUpdatedDelegate, H>
    {
        type(H&& handler) : implements_delegate<Microsoft::Azure::SpatialAnchors::SessionUpdatedDelegate, H>(std::forward<H>(handler)) {}

        int32_t WINRT_CALL Invoke(void* sender, void* args) noexcept final
        {
            try
            {
                (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Microsoft::Azure::SpatialAnchors::SessionUpdatedEventArgs const*>(&args));
                return 0;
            }
            catch (...)
            {
                return to_hresult();
            }
        }
    };
};

template <> struct delegate<Microsoft::Azure::SpatialAnchors::TokenRequiredDelegate>
{
    template <typename H>
    struct type : implements_delegate<Microsoft::Azure::SpatialAnchors::TokenRequiredDelegate, H>
    {
        type(H&& handler) : implements_delegate<Microsoft::Azure::SpatialAnchors::TokenRequiredDelegate, H>(std::forward<H>(handler)) {}

        int32_t WINRT_CALL Invoke(void* sender, void* args) noexcept final
        {
            try
            {
                (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Microsoft::Azure::SpatialAnchors::TokenRequiredEventArgs const*>(&args));
                return 0;
            }
            catch (...)
            {
                return to_hresult();
            }
        }
    };
};

template <typename D>
struct produce<D, Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria> : produce_base<D, Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria>
{
    int32_t WINRT_CALL get_Identifiers(uint32_t* __valueSize, void*** value) noexcept final
    {
        try
        {
            *__valueSize = 0;
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Identifiers, WINRT_WRAP(com_array<hstring>));
            std::tie(*__valueSize, *value) = detach_abi(this->shim().Identifiers());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_Identifiers(uint32_t __valueSize, void** value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Identifiers, WINRT_WRAP(void), array_view<hstring const>);
            this->shim().Identifiers(array_view<hstring const>(reinterpret_cast<hstring const *>(value), reinterpret_cast<hstring const *>(value) + __valueSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_BypassCache(bool* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(BypassCache, WINRT_WRAP(bool));
            *value = detach_from<bool>(this->shim().BypassCache());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_BypassCache(bool value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(BypassCache, WINRT_WRAP(void), bool);
            this->shim().BypassCache(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_NearAnchor(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(NearAnchor, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::NearAnchorCriteria));
            *value = detach_from<Microsoft::Azure::SpatialAnchors::NearAnchorCriteria>(this->shim().NearAnchor());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_NearAnchor(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(NearAnchor, WINRT_WRAP(void), Microsoft::Azure::SpatialAnchors::NearAnchorCriteria const&);
            this->shim().NearAnchor(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::NearAnchorCriteria const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_RequestedCategories(Microsoft::Azure::SpatialAnchors::AnchorDataCategory* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(RequestedCategories, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::AnchorDataCategory));
            *value = detach_from<Microsoft::Azure::SpatialAnchors::AnchorDataCategory>(this->shim().RequestedCategories());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_RequestedCategories(Microsoft::Azure::SpatialAnchors::AnchorDataCategory value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(RequestedCategories, WINRT_WRAP(void), Microsoft::Azure::SpatialAnchors::AnchorDataCategory const&);
            this->shim().RequestedCategories(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::AnchorDataCategory const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_Strategy(Microsoft::Azure::SpatialAnchors::LocateStrategy* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Strategy, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::LocateStrategy));
            *value = detach_from<Microsoft::Azure::SpatialAnchors::LocateStrategy>(this->shim().Strategy());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_Strategy(Microsoft::Azure::SpatialAnchors::LocateStrategy value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Strategy, WINRT_WRAP(void), Microsoft::Azure::SpatialAnchors::LocateStrategy const&);
            this->shim().Strategy(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::LocateStrategy const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs> : produce_base<D, Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs>
{
    int32_t WINRT_CALL get_Anchor(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Anchor, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor));
            *value = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor>(this->shim().Anchor());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_Identifier(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Identifier, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().Identifier());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_Status(Microsoft::Azure::SpatialAnchors::LocateAnchorStatus* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Status, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::LocateAnchorStatus));
            *value = detach_from<Microsoft::Azure::SpatialAnchors::LocateAnchorStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_Watcher(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Watcher, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher));
            *value = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher>(this->shim().Watcher());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor> : produce_base<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor>
{
    int32_t WINRT_CALL get_LocalAnchor(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(LocalAnchor, WINRT_WRAP(Windows::Perception::Spatial::SpatialAnchor));
            *value = detach_from<Windows::Perception::Spatial::SpatialAnchor>(this->shim().LocalAnchor());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_LocalAnchor(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(LocalAnchor, WINRT_WRAP(void), Windows::Perception::Spatial::SpatialAnchor const&);
            this->shim().LocalAnchor(*reinterpret_cast<Windows::Perception::Spatial::SpatialAnchor const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_Expiration(Windows::Foundation::DateTime* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Expiration, WINRT_WRAP(Windows::Foundation::DateTime));
            *value = detach_from<Windows::Foundation::DateTime>(this->shim().Expiration());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_Expiration(Windows::Foundation::DateTime value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Expiration, WINRT_WRAP(void), Windows::Foundation::DateTime const&);
            this->shim().Expiration(*reinterpret_cast<Windows::Foundation::DateTime const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_Identifier(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Identifier, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().Identifier());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_AppProperties(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AppProperties, WINRT_WRAP(Windows::Foundation::Collections::IMap<hstring, hstring>));
            *value = detach_from<Windows::Foundation::Collections::IMap<hstring, hstring>>(this->shim().AppProperties());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_VersionTag(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(VersionTag, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().VersionTag());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession> : produce_base<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession>
{
    int32_t WINRT_CALL get_Configuration(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Configuration, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::SessionConfiguration));
            *value = detach_from<Microsoft::Azure::SpatialAnchors::SessionConfiguration>(this->shim().Configuration());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_Diagnostics(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Diagnostics, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics));
            *value = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics>(this->shim().Diagnostics());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_LogLevel(Microsoft::Azure::SpatialAnchors::SessionLogLevel* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(LogLevel, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::SessionLogLevel));
            *value = detach_from<Microsoft::Azure::SpatialAnchors::SessionLogLevel>(this->shim().LogLevel());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_LogLevel(Microsoft::Azure::SpatialAnchors::SessionLogLevel value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(LogLevel, WINRT_WRAP(void), Microsoft::Azure::SpatialAnchors::SessionLogLevel const&);
            this->shim().LogLevel(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::SessionLogLevel const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_SessionId(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(SessionId, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().SessionId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL add_TokenRequired(void* handler, winrt::event_token* token) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(TokenRequired, WINRT_WRAP(winrt::event_token), Microsoft::Azure::SpatialAnchors::TokenRequiredDelegate const&);
            *token = detach_from<winrt::event_token>(this->shim().TokenRequired(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::TokenRequiredDelegate const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL remove_TokenRequired(winrt::event_token token) noexcept final
    {
        typename D::abi_guard guard(this->shim());
        WINRT_ASSERT_DECLARATION(TokenRequired, WINRT_WRAP(void), winrt::event_token const&);
        this->shim().TokenRequired(*reinterpret_cast<winrt::event_token const*>(&token));
        return 0;
    }

    int32_t WINRT_CALL add_AnchorLocated(void* handler, winrt::event_token* token) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AnchorLocated, WINRT_WRAP(winrt::event_token), Microsoft::Azure::SpatialAnchors::AnchorLocatedDelegate const&);
            *token = detach_from<winrt::event_token>(this->shim().AnchorLocated(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::AnchorLocatedDelegate const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL remove_AnchorLocated(winrt::event_token token) noexcept final
    {
        typename D::abi_guard guard(this->shim());
        WINRT_ASSERT_DECLARATION(AnchorLocated, WINRT_WRAP(void), winrt::event_token const&);
        this->shim().AnchorLocated(*reinterpret_cast<winrt::event_token const*>(&token));
        return 0;
    }

    int32_t WINRT_CALL add_LocateAnchorsCompleted(void* handler, winrt::event_token* token) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(LocateAnchorsCompleted, WINRT_WRAP(winrt::event_token), Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedDelegate const&);
            *token = detach_from<winrt::event_token>(this->shim().LocateAnchorsCompleted(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedDelegate const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL remove_LocateAnchorsCompleted(winrt::event_token token) noexcept final
    {
        typename D::abi_guard guard(this->shim());
        WINRT_ASSERT_DECLARATION(LocateAnchorsCompleted, WINRT_WRAP(void), winrt::event_token const&);
        this->shim().LocateAnchorsCompleted(*reinterpret_cast<winrt::event_token const*>(&token));
        return 0;
    }

    int32_t WINRT_CALL add_SessionUpdated(void* handler, winrt::event_token* token) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(SessionUpdated, WINRT_WRAP(winrt::event_token), Microsoft::Azure::SpatialAnchors::SessionUpdatedDelegate const&);
            *token = detach_from<winrt::event_token>(this->shim().SessionUpdated(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::SessionUpdatedDelegate const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL remove_SessionUpdated(winrt::event_token token) noexcept final
    {
        typename D::abi_guard guard(this->shim());
        WINRT_ASSERT_DECLARATION(SessionUpdated, WINRT_WRAP(void), winrt::event_token const&);
        this->shim().SessionUpdated(*reinterpret_cast<winrt::event_token const*>(&token));
        return 0;
    }

    int32_t WINRT_CALL add_Error(void* handler, winrt::event_token* token) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Error, WINRT_WRAP(winrt::event_token), Microsoft::Azure::SpatialAnchors::SessionErrorDelegate const&);
            *token = detach_from<winrt::event_token>(this->shim().Error(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::SessionErrorDelegate const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL remove_Error(winrt::event_token token) noexcept final
    {
        typename D::abi_guard guard(this->shim());
        WINRT_ASSERT_DECLARATION(Error, WINRT_WRAP(void), winrt::event_token const&);
        this->shim().Error(*reinterpret_cast<winrt::event_token const*>(&token));
        return 0;
    }

    int32_t WINRT_CALL add_OnLogDebug(void* handler, winrt::event_token* token) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(OnLogDebug, WINRT_WRAP(winrt::event_token), Microsoft::Azure::SpatialAnchors::OnLogDebugDelegate const&);
            *token = detach_from<winrt::event_token>(this->shim().OnLogDebug(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::OnLogDebugDelegate const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL remove_OnLogDebug(winrt::event_token token) noexcept final
    {
        typename D::abi_guard guard(this->shim());
        WINRT_ASSERT_DECLARATION(OnLogDebug, WINRT_WRAP(void), winrt::event_token const&);
        this->shim().OnLogDebug(*reinterpret_cast<winrt::event_token const*>(&token));
        return 0;
    }

    int32_t WINRT_CALL Dispose() noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Dispose, WINRT_WRAP(void));
            this->shim().Dispose();
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL GetAccessTokenWithAuthenticationTokenAsync(void* authenticationToken, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(GetAccessTokenWithAuthenticationTokenAsync, WINRT_WRAP(Windows::Foundation::IAsyncOperation<hstring>), hstring const);
            *operation = detach_from<Windows::Foundation::IAsyncOperation<hstring>>(this->shim().GetAccessTokenWithAuthenticationTokenAsync(*reinterpret_cast<hstring const*>(&authenticationToken)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL GetAccessTokenWithAccountKeyAsync(void* accountKey, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(GetAccessTokenWithAccountKeyAsync, WINRT_WRAP(Windows::Foundation::IAsyncOperation<hstring>), hstring const);
            *operation = detach_from<Windows::Foundation::IAsyncOperation<hstring>>(this->shim().GetAccessTokenWithAccountKeyAsync(*reinterpret_cast<hstring const*>(&accountKey)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateAnchorAsync(void* anchor, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateAnchorAsync, WINRT_WRAP(Windows::Foundation::IAsyncAction), Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const);
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().CreateAnchorAsync(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const*>(&anchor)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateWatcher(void* criteria, void** result) noexcept final
    {
        try
        {
            *result = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateWatcher, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher), Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria const&);
            *result = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher>(this->shim().CreateWatcher(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria const*>(&criteria)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL GetAnchorPropertiesAsync(void* identifier, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(GetAnchorPropertiesAsync, WINRT_WRAP(Windows::Foundation::IAsyncOperation<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor>), hstring const);
            *operation = detach_from<Windows::Foundation::IAsyncOperation<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor>>(this->shim().GetAnchorPropertiesAsync(*reinterpret_cast<hstring const*>(&identifier)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL GetActiveWatchers(void** result) noexcept final
    {
        try
        {
            *result = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(GetActiveWatchers, WINRT_WRAP(Windows::Foundation::Collections::IVectorView<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher>));
            *result = detach_from<Windows::Foundation::Collections::IVectorView<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher>>(this->shim().GetActiveWatchers());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL RefreshAnchorPropertiesAsync(void* anchor, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(RefreshAnchorPropertiesAsync, WINRT_WRAP(Windows::Foundation::IAsyncAction), Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const);
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().RefreshAnchorPropertiesAsync(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const*>(&anchor)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL UpdateAnchorPropertiesAsync(void* anchor, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(UpdateAnchorPropertiesAsync, WINRT_WRAP(Windows::Foundation::IAsyncAction), Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const);
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().UpdateAnchorPropertiesAsync(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const*>(&anchor)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL DeleteAnchorAsync(void* anchor, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(DeleteAnchorAsync, WINRT_WRAP(Windows::Foundation::IAsyncAction), Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const);
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().DeleteAnchorAsync(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const*>(&anchor)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL GetSessionStatusAsync(void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(GetSessionStatusAsync, WINRT_WRAP(Windows::Foundation::IAsyncOperation<Microsoft::Azure::SpatialAnchors::SessionStatus>));
            *operation = detach_from<Windows::Foundation::IAsyncOperation<Microsoft::Azure::SpatialAnchors::SessionStatus>>(this->shim().GetSessionStatusAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL Start() noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Start, WINRT_WRAP(void));
            this->shim().Start();
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL Stop() noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Stop, WINRT_WRAP(void));
            this->shim().Stop();
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL Reset() noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Reset, WINRT_WRAP(void));
            this->shim().Reset();
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDeferral> : produce_base<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDeferral>
{
    int32_t WINRT_CALL Complete() noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Complete, WINRT_WRAP(void));
            this->shim().Complete();
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics> : produce_base<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics>
{
    int32_t WINRT_CALL get_LogLevel(Microsoft::Azure::SpatialAnchors::SessionLogLevel* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(LogLevel, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::SessionLogLevel));
            *value = detach_from<Microsoft::Azure::SpatialAnchors::SessionLogLevel>(this->shim().LogLevel());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_LogLevel(Microsoft::Azure::SpatialAnchors::SessionLogLevel value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(LogLevel, WINRT_WRAP(void), Microsoft::Azure::SpatialAnchors::SessionLogLevel const&);
            this->shim().LogLevel(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::SessionLogLevel const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_LogDirectory(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(LogDirectory, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().LogDirectory());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_LogDirectory(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(LogDirectory, WINRT_WRAP(void), hstring const&);
            this->shim().LogDirectory(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_MaxDiskSizeInMB(int32_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(MaxDiskSizeInMB, WINRT_WRAP(int32_t));
            *value = detach_from<int32_t>(this->shim().MaxDiskSizeInMB());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_MaxDiskSizeInMB(int32_t value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(MaxDiskSizeInMB, WINRT_WRAP(void), int32_t);
            this->shim().MaxDiskSizeInMB(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ImagesEnabled(bool* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ImagesEnabled, WINRT_WRAP(bool));
            *value = detach_from<bool>(this->shim().ImagesEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_ImagesEnabled(bool value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ImagesEnabled, WINRT_WRAP(void), bool);
            this->shim().ImagesEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateManifestAsync(void* description, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateManifestAsync, WINRT_WRAP(Windows::Foundation::IAsyncOperation<hstring>), hstring const);
            *operation = detach_from<Windows::Foundation::IAsyncOperation<hstring>>(this->shim().CreateManifestAsync(*reinterpret_cast<hstring const*>(&description)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL SubmitManifestAsync(void* manifestPath, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(SubmitManifestAsync, WINRT_WRAP(Windows::Foundation::IAsyncAction), hstring const);
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().SubmitManifestAsync(*reinterpret_cast<hstring const*>(&manifestPath)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorWatcher> : produce_base<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorWatcher>
{
    int32_t WINRT_CALL get_Identifier(int32_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Identifier, WINRT_WRAP(int32_t));
            *value = detach_from<int32_t>(this->shim().Identifier());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL Stop() noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Stop, WINRT_WRAP(void));
            this->shim().Stop();
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Azure::SpatialAnchors::ILocateAnchorsCompletedEventArgs> : produce_base<D, Microsoft::Azure::SpatialAnchors::ILocateAnchorsCompletedEventArgs>
{
    int32_t WINRT_CALL get_Cancelled(bool* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Cancelled, WINRT_WRAP(bool));
            *value = detach_from<bool>(this->shim().Cancelled());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_Watcher(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Watcher, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher));
            *value = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher>(this->shim().Watcher());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Azure::SpatialAnchors::INearAnchorCriteria> : produce_base<D, Microsoft::Azure::SpatialAnchors::INearAnchorCriteria>
{
    int32_t WINRT_CALL get_SourceAnchor(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(SourceAnchor, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor));
            *value = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor>(this->shim().SourceAnchor());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_SourceAnchor(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(SourceAnchor, WINRT_WRAP(void), Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const&);
            this->shim().SourceAnchor(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_DistanceInMeters(float* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(DistanceInMeters, WINRT_WRAP(float));
            *value = detach_from<float>(this->shim().DistanceInMeters());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_DistanceInMeters(float value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(DistanceInMeters, WINRT_WRAP(void), float);
            this->shim().DistanceInMeters(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_MaxResultCount(int32_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(MaxResultCount, WINRT_WRAP(int32_t));
            *value = detach_from<int32_t>(this->shim().MaxResultCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_MaxResultCount(int32_t value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(MaxResultCount, WINRT_WRAP(void), int32_t);
            this->shim().MaxResultCount(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Azure::SpatialAnchors::IOnLogDebugEventArgs> : produce_base<D, Microsoft::Azure::SpatialAnchors::IOnLogDebugEventArgs>
{
    int32_t WINRT_CALL get_Message(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Message, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().Message());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Azure::SpatialAnchors::ISessionConfiguration> : produce_base<D, Microsoft::Azure::SpatialAnchors::ISessionConfiguration>
{
    int32_t WINRT_CALL get_AccountDomain(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AccountDomain, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().AccountDomain());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_AccountDomain(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AccountDomain, WINRT_WRAP(void), hstring const&);
            this->shim().AccountDomain(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_AccountId(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AccountId, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().AccountId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_AccountId(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AccountId, WINRT_WRAP(void), hstring const&);
            this->shim().AccountId(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_AuthenticationToken(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AuthenticationToken, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().AuthenticationToken());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_AuthenticationToken(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AuthenticationToken, WINRT_WRAP(void), hstring const&);
            this->shim().AuthenticationToken(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_AccountKey(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AccountKey, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().AccountKey());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_AccountKey(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AccountKey, WINRT_WRAP(void), hstring const&);
            this->shim().AccountKey(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_AccessToken(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AccessToken, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().AccessToken());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_AccessToken(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AccessToken, WINRT_WRAP(void), hstring const&);
            this->shim().AccessToken(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs> : produce_base<D, Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs>
{
    int32_t WINRT_CALL get_ErrorCode(Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ErrorCode, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode));
            *value = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode>(this->shim().ErrorCode());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ErrorMessage(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ErrorMessage, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().ErrorMessage());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_Watcher(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Watcher, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher));
            *value = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher>(this->shim().Watcher());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Azure::SpatialAnchors::ISessionStatus> : produce_base<D, Microsoft::Azure::SpatialAnchors::ISessionStatus>
{
    int32_t WINRT_CALL get_ReadyForCreateProgress(float* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ReadyForCreateProgress, WINRT_WRAP(float));
            *value = detach_from<float>(this->shim().ReadyForCreateProgress());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_RecommendedForCreateProgress(float* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(RecommendedForCreateProgress, WINRT_WRAP(float));
            *value = detach_from<float>(this->shim().RecommendedForCreateProgress());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_SessionCreateHash(int32_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(SessionCreateHash, WINRT_WRAP(int32_t));
            *value = detach_from<int32_t>(this->shim().SessionCreateHash());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_SessionLocateHash(int32_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(SessionLocateHash, WINRT_WRAP(int32_t));
            *value = detach_from<int32_t>(this->shim().SessionLocateHash());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_UserFeedback(Microsoft::Azure::SpatialAnchors::SessionUserFeedback* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(UserFeedback, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::SessionUserFeedback));
            *value = detach_from<Microsoft::Azure::SpatialAnchors::SessionUserFeedback>(this->shim().UserFeedback());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Azure::SpatialAnchors::ISessionUpdatedEventArgs> : produce_base<D, Microsoft::Azure::SpatialAnchors::ISessionUpdatedEventArgs>
{
    int32_t WINRT_CALL get_Status(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Status, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::SessionStatus));
            *value = detach_from<Microsoft::Azure::SpatialAnchors::SessionStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Azure::SpatialAnchors::ISpatialAnchorsFactory> : produce_base<D, Microsoft::Azure::SpatialAnchors::ISpatialAnchorsFactory>
{
    int32_t WINRT_CALL CreateAnchorLocateCriteria(void** result) noexcept final
    {
        try
        {
            *result = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateAnchorLocateCriteria, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria));
            *result = detach_from<Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria>(this->shim().CreateAnchorLocateCriteria());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateCloudSpatialAnchor(void** result) noexcept final
    {
        try
        {
            *result = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateCloudSpatialAnchor, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor));
            *result = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor>(this->shim().CreateCloudSpatialAnchor());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateCloudSpatialAnchorSession(void** result) noexcept final
    {
        try
        {
            *result = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateCloudSpatialAnchorSession, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSession));
            *result = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSession>(this->shim().CreateCloudSpatialAnchorSession());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL CreateNearAnchorCriteria(void** result) noexcept final
    {
        try
        {
            *result = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateNearAnchorCriteria, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::NearAnchorCriteria));
            *result = detach_from<Microsoft::Azure::SpatialAnchors::NearAnchorCriteria>(this->shim().CreateNearAnchorCriteria());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs> : produce_base<D, Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs>
{
    int32_t WINRT_CALL get_AccessToken(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AccessToken, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().AccessToken());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_AccessToken(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AccessToken, WINRT_WRAP(void), hstring const&);
            this->shim().AccessToken(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_AuthenticationToken(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AuthenticationToken, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().AuthenticationToken());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_AuthenticationToken(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AuthenticationToken, WINRT_WRAP(void), hstring const&);
            this->shim().AuthenticationToken(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL GetDeferral(void** result) noexcept final
    {
        try
        {
            *result = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(GetDeferral, WINRT_WRAP(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDeferral));
            *result = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDeferral>(this->shim().GetDeferral());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

}

WINRT_EXPORT namespace winrt::Microsoft::Azure::SpatialAnchors {

template <typename L> AnchorLocatedDelegate::AnchorLocatedDelegate(L handler) :
    AnchorLocatedDelegate(impl::make_delegate<AnchorLocatedDelegate>(std::forward<L>(handler)))
{}

template <typename F> AnchorLocatedDelegate::AnchorLocatedDelegate(F* handler) :
    AnchorLocatedDelegate([=](auto&&... args) { return handler(args...); })
{}

template <typename O, typename M> AnchorLocatedDelegate::AnchorLocatedDelegate(O* object, M method) :
    AnchorLocatedDelegate([=](auto&&... args) { return ((*object).*(method))(args...); })
{}

template <typename O, typename M> AnchorLocatedDelegate::AnchorLocatedDelegate(com_ptr<O>&& object, M method) :
    AnchorLocatedDelegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
{}

template <typename O, typename M> AnchorLocatedDelegate::AnchorLocatedDelegate(weak_ref<O>&& object, M method) :
    AnchorLocatedDelegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
{}

inline void AnchorLocatedDelegate::operator()(Windows::Foundation::IInspectable const& sender, Microsoft::Azure::SpatialAnchors::AnchorLocatedEventArgs const& args) const
{
    check_hresult((*(impl::abi_t<AnchorLocatedDelegate>**)this)->Invoke(get_abi(sender), get_abi(args)));
}

template <typename L> LocateAnchorsCompletedDelegate::LocateAnchorsCompletedDelegate(L handler) :
    LocateAnchorsCompletedDelegate(impl::make_delegate<LocateAnchorsCompletedDelegate>(std::forward<L>(handler)))
{}

template <typename F> LocateAnchorsCompletedDelegate::LocateAnchorsCompletedDelegate(F* handler) :
    LocateAnchorsCompletedDelegate([=](auto&&... args) { return handler(args...); })
{}

template <typename O, typename M> LocateAnchorsCompletedDelegate::LocateAnchorsCompletedDelegate(O* object, M method) :
    LocateAnchorsCompletedDelegate([=](auto&&... args) { return ((*object).*(method))(args...); })
{}

template <typename O, typename M> LocateAnchorsCompletedDelegate::LocateAnchorsCompletedDelegate(com_ptr<O>&& object, M method) :
    LocateAnchorsCompletedDelegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
{}

template <typename O, typename M> LocateAnchorsCompletedDelegate::LocateAnchorsCompletedDelegate(weak_ref<O>&& object, M method) :
    LocateAnchorsCompletedDelegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
{}

inline void LocateAnchorsCompletedDelegate::operator()(Windows::Foundation::IInspectable const& sender, Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedEventArgs const& args) const
{
    check_hresult((*(impl::abi_t<LocateAnchorsCompletedDelegate>**)this)->Invoke(get_abi(sender), get_abi(args)));
}

template <typename L> OnLogDebugDelegate::OnLogDebugDelegate(L handler) :
    OnLogDebugDelegate(impl::make_delegate<OnLogDebugDelegate>(std::forward<L>(handler)))
{}

template <typename F> OnLogDebugDelegate::OnLogDebugDelegate(F* handler) :
    OnLogDebugDelegate([=](auto&&... args) { return handler(args...); })
{}

template <typename O, typename M> OnLogDebugDelegate::OnLogDebugDelegate(O* object, M method) :
    OnLogDebugDelegate([=](auto&&... args) { return ((*object).*(method))(args...); })
{}

template <typename O, typename M> OnLogDebugDelegate::OnLogDebugDelegate(com_ptr<O>&& object, M method) :
    OnLogDebugDelegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
{}

template <typename O, typename M> OnLogDebugDelegate::OnLogDebugDelegate(weak_ref<O>&& object, M method) :
    OnLogDebugDelegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
{}

inline void OnLogDebugDelegate::operator()(Windows::Foundation::IInspectable const& sender, Microsoft::Azure::SpatialAnchors::OnLogDebugEventArgs const& args) const
{
    check_hresult((*(impl::abi_t<OnLogDebugDelegate>**)this)->Invoke(get_abi(sender), get_abi(args)));
}

template <typename L> SessionErrorDelegate::SessionErrorDelegate(L handler) :
    SessionErrorDelegate(impl::make_delegate<SessionErrorDelegate>(std::forward<L>(handler)))
{}

template <typename F> SessionErrorDelegate::SessionErrorDelegate(F* handler) :
    SessionErrorDelegate([=](auto&&... args) { return handler(args...); })
{}

template <typename O, typename M> SessionErrorDelegate::SessionErrorDelegate(O* object, M method) :
    SessionErrorDelegate([=](auto&&... args) { return ((*object).*(method))(args...); })
{}

template <typename O, typename M> SessionErrorDelegate::SessionErrorDelegate(com_ptr<O>&& object, M method) :
    SessionErrorDelegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
{}

template <typename O, typename M> SessionErrorDelegate::SessionErrorDelegate(weak_ref<O>&& object, M method) :
    SessionErrorDelegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
{}

inline void SessionErrorDelegate::operator()(Windows::Foundation::IInspectable const& sender, Microsoft::Azure::SpatialAnchors::SessionErrorEventArgs const& args) const
{
    check_hresult((*(impl::abi_t<SessionErrorDelegate>**)this)->Invoke(get_abi(sender), get_abi(args)));
}

template <typename L> SessionUpdatedDelegate::SessionUpdatedDelegate(L handler) :
    SessionUpdatedDelegate(impl::make_delegate<SessionUpdatedDelegate>(std::forward<L>(handler)))
{}

template <typename F> SessionUpdatedDelegate::SessionUpdatedDelegate(F* handler) :
    SessionUpdatedDelegate([=](auto&&... args) { return handler(args...); })
{}

template <typename O, typename M> SessionUpdatedDelegate::SessionUpdatedDelegate(O* object, M method) :
    SessionUpdatedDelegate([=](auto&&... args) { return ((*object).*(method))(args...); })
{}

template <typename O, typename M> SessionUpdatedDelegate::SessionUpdatedDelegate(com_ptr<O>&& object, M method) :
    SessionUpdatedDelegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
{}

template <typename O, typename M> SessionUpdatedDelegate::SessionUpdatedDelegate(weak_ref<O>&& object, M method) :
    SessionUpdatedDelegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
{}

inline void SessionUpdatedDelegate::operator()(Windows::Foundation::IInspectable const& sender, Microsoft::Azure::SpatialAnchors::SessionUpdatedEventArgs const& args) const
{
    check_hresult((*(impl::abi_t<SessionUpdatedDelegate>**)this)->Invoke(get_abi(sender), get_abi(args)));
}

template <typename L> TokenRequiredDelegate::TokenRequiredDelegate(L handler) :
    TokenRequiredDelegate(impl::make_delegate<TokenRequiredDelegate>(std::forward<L>(handler)))
{}

template <typename F> TokenRequiredDelegate::TokenRequiredDelegate(F* handler) :
    TokenRequiredDelegate([=](auto&&... args) { return handler(args...); })
{}

template <typename O, typename M> TokenRequiredDelegate::TokenRequiredDelegate(O* object, M method) :
    TokenRequiredDelegate([=](auto&&... args) { return ((*object).*(method))(args...); })
{}

template <typename O, typename M> TokenRequiredDelegate::TokenRequiredDelegate(com_ptr<O>&& object, M method) :
    TokenRequiredDelegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
{}

template <typename O, typename M> TokenRequiredDelegate::TokenRequiredDelegate(weak_ref<O>&& object, M method) :
    TokenRequiredDelegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
{}

inline void TokenRequiredDelegate::operator()(Windows::Foundation::IInspectable const& sender, Microsoft::Azure::SpatialAnchors::TokenRequiredEventArgs const& args) const
{
    check_hresult((*(impl::abi_t<TokenRequiredDelegate>**)this)->Invoke(get_abi(sender), get_abi(args)));
}

}

namespace winrt::impl {

struct property_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria
{ struct named {
    struct BypassCache
    {
        struct name { static constexpr std::wstring_view value{ L"BypassCache"sv }; };
        using property_type = bool;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.BypassCache();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.BypassCache(std::forward<Value>(value));
            }
        };
    };
    struct Identifiers
    {
        struct name { static constexpr std::wstring_view value{ L"Identifiers"sv }; };
        using property_type = com_array<hstring>;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Identifiers();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.Identifiers(std::forward<Value>(value));
            }
        };
    };
    struct NearAnchor
    {
        struct name { static constexpr std::wstring_view value{ L"NearAnchor"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::NearAnchorCriteria;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.NearAnchor();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.NearAnchor(std::forward<Value>(value));
            }
        };
    };
    struct RequestedCategories
    {
        struct name { static constexpr std::wstring_view value{ L"RequestedCategories"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::AnchorDataCategory;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.RequestedCategories();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.RequestedCategories(std::forward<Value>(value));
            }
        };
    };
    struct Strategy
    {
        struct name { static constexpr std::wstring_view value{ L"Strategy"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::LocateStrategy;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Strategy();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.Strategy(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::BypassCache, named::Identifiers, named::NearAnchor, named::RequestedCategories, named::Strategy>; };
};

struct property_Microsoft_Azure_SpatialAnchors_IAnchorLocatedEventArgs
{ struct named {
    struct Anchor
    {
        struct name { static constexpr std::wstring_view value{ L"Anchor"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Anchor();
            }
        };
    };
    struct Identifier
    {
        struct name { static constexpr std::wstring_view value{ L"Identifier"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Identifier();
            }
        };
    };
    struct Status
    {
        struct name { static constexpr std::wstring_view value{ L"Status"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::LocateAnchorStatus;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Status();
            }
        };
    };
    struct Watcher
    {
        struct name { static constexpr std::wstring_view value{ L"Watcher"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Watcher();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Anchor, named::Identifier, named::Status, named::Watcher>; };
};

struct property_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor
{ struct named {
    struct AppProperties
    {
        struct name { static constexpr std::wstring_view value{ L"AppProperties"sv }; };
        using property_type = winrt::Windows::Foundation::Collections::IMap<hstring, hstring>;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.AppProperties();
            }
        };
    };
    struct Expiration
    {
        struct name { static constexpr std::wstring_view value{ L"Expiration"sv }; };
        using property_type = winrt::Windows::Foundation::DateTime;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Expiration();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.Expiration(std::forward<Value>(value));
            }
        };
    };
    struct Identifier
    {
        struct name { static constexpr std::wstring_view value{ L"Identifier"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Identifier();
            }
        };
    };
    struct LocalAnchor
    {
        struct name { static constexpr std::wstring_view value{ L"LocalAnchor"sv }; };
        using property_type = winrt::Windows::Perception::Spatial::SpatialAnchor;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.LocalAnchor();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.LocalAnchor(std::forward<Value>(value));
            }
        };
    };
    struct VersionTag
    {
        struct name { static constexpr std::wstring_view value{ L"VersionTag"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.VersionTag();
            }
        };
    };};
    struct list { using type = impl::typelist<named::AppProperties, named::Expiration, named::Identifier, named::LocalAnchor, named::VersionTag>; };
};

struct property_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession
{ struct named {
    struct Configuration
    {
        struct name { static constexpr std::wstring_view value{ L"Configuration"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::SessionConfiguration;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Configuration();
            }
        };
    };
    struct Diagnostics
    {
        struct name { static constexpr std::wstring_view value{ L"Diagnostics"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Diagnostics();
            }
        };
    };
    struct LogLevel
    {
        struct name { static constexpr std::wstring_view value{ L"LogLevel"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::SessionLogLevel;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.LogLevel();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.LogLevel(std::forward<Value>(value));
            }
        };
    };
    struct SessionId
    {
        struct name { static constexpr std::wstring_view value{ L"SessionId"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.SessionId();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Configuration, named::Diagnostics, named::LogLevel, named::SessionId>; };
};

struct property_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics
{ struct named {
    struct ImagesEnabled
    {
        struct name { static constexpr std::wstring_view value{ L"ImagesEnabled"sv }; };
        using property_type = bool;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ImagesEnabled();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ImagesEnabled(std::forward<Value>(value));
            }
        };
    };
    struct LogDirectory
    {
        struct name { static constexpr std::wstring_view value{ L"LogDirectory"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.LogDirectory();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.LogDirectory(std::forward<Value>(value));
            }
        };
    };
    struct LogLevel
    {
        struct name { static constexpr std::wstring_view value{ L"LogLevel"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::SessionLogLevel;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.LogLevel();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.LogLevel(std::forward<Value>(value));
            }
        };
    };
    struct MaxDiskSizeInMB
    {
        struct name { static constexpr std::wstring_view value{ L"MaxDiskSizeInMB"sv }; };
        using property_type = int32_t;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.MaxDiskSizeInMB();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.MaxDiskSizeInMB(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::ImagesEnabled, named::LogDirectory, named::LogLevel, named::MaxDiskSizeInMB>; };
};

struct property_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorWatcher
{ struct named {
    struct Identifier
    {
        struct name { static constexpr std::wstring_view value{ L"Identifier"sv }; };
        using property_type = int32_t;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorWatcher;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Identifier();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Identifier>; };
};

struct property_Microsoft_Azure_SpatialAnchors_ILocateAnchorsCompletedEventArgs
{ struct named {
    struct Cancelled
    {
        struct name { static constexpr std::wstring_view value{ L"Cancelled"sv }; };
        using property_type = bool;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ILocateAnchorsCompletedEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Cancelled();
            }
        };
    };
    struct Watcher
    {
        struct name { static constexpr std::wstring_view value{ L"Watcher"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ILocateAnchorsCompletedEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Watcher();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Cancelled, named::Watcher>; };
};

struct property_Microsoft_Azure_SpatialAnchors_INearAnchorCriteria
{ struct named {
    struct DistanceInMeters
    {
        struct name { static constexpr std::wstring_view value{ L"DistanceInMeters"sv }; };
        using property_type = float;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::INearAnchorCriteria;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.DistanceInMeters();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.DistanceInMeters(std::forward<Value>(value));
            }
        };
    };
    struct MaxResultCount
    {
        struct name { static constexpr std::wstring_view value{ L"MaxResultCount"sv }; };
        using property_type = int32_t;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::INearAnchorCriteria;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.MaxResultCount();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.MaxResultCount(std::forward<Value>(value));
            }
        };
    };
    struct SourceAnchor
    {
        struct name { static constexpr std::wstring_view value{ L"SourceAnchor"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::INearAnchorCriteria;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.SourceAnchor();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.SourceAnchor(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::DistanceInMeters, named::MaxResultCount, named::SourceAnchor>; };
};

struct property_Microsoft_Azure_SpatialAnchors_IOnLogDebugEventArgs
{ struct named {
    struct Message
    {
        struct name { static constexpr std::wstring_view value{ L"Message"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::IOnLogDebugEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Message();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Message>; };
};

struct property_Microsoft_Azure_SpatialAnchors_ISessionConfiguration
{ struct named {
    struct AccessToken
    {
        struct name { static constexpr std::wstring_view value{ L"AccessToken"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ISessionConfiguration;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.AccessToken();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.AccessToken(std::forward<Value>(value));
            }
        };
    };
    struct AccountDomain
    {
        struct name { static constexpr std::wstring_view value{ L"AccountDomain"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ISessionConfiguration;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.AccountDomain();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.AccountDomain(std::forward<Value>(value));
            }
        };
    };
    struct AccountId
    {
        struct name { static constexpr std::wstring_view value{ L"AccountId"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ISessionConfiguration;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.AccountId();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.AccountId(std::forward<Value>(value));
            }
        };
    };
    struct AccountKey
    {
        struct name { static constexpr std::wstring_view value{ L"AccountKey"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ISessionConfiguration;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.AccountKey();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.AccountKey(std::forward<Value>(value));
            }
        };
    };
    struct AuthenticationToken
    {
        struct name { static constexpr std::wstring_view value{ L"AuthenticationToken"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ISessionConfiguration;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.AuthenticationToken();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.AuthenticationToken(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::AccessToken, named::AccountDomain, named::AccountId, named::AccountKey, named::AuthenticationToken>; };
};

struct property_Microsoft_Azure_SpatialAnchors_ISessionErrorEventArgs
{ struct named {
    struct ErrorCode
    {
        struct name { static constexpr std::wstring_view value{ L"ErrorCode"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ErrorCode();
            }
        };
    };
    struct ErrorMessage
    {
        struct name { static constexpr std::wstring_view value{ L"ErrorMessage"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ErrorMessage();
            }
        };
    };
    struct Watcher
    {
        struct name { static constexpr std::wstring_view value{ L"Watcher"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Watcher();
            }
        };
    };};
    struct list { using type = impl::typelist<named::ErrorCode, named::ErrorMessage, named::Watcher>; };
};

struct property_Microsoft_Azure_SpatialAnchors_ISessionStatus
{ struct named {
    struct ReadyForCreateProgress
    {
        struct name { static constexpr std::wstring_view value{ L"ReadyForCreateProgress"sv }; };
        using property_type = float;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ISessionStatus;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ReadyForCreateProgress();
            }
        };
    };
    struct RecommendedForCreateProgress
    {
        struct name { static constexpr std::wstring_view value{ L"RecommendedForCreateProgress"sv }; };
        using property_type = float;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ISessionStatus;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.RecommendedForCreateProgress();
            }
        };
    };
    struct SessionCreateHash
    {
        struct name { static constexpr std::wstring_view value{ L"SessionCreateHash"sv }; };
        using property_type = int32_t;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ISessionStatus;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.SessionCreateHash();
            }
        };
    };
    struct SessionLocateHash
    {
        struct name { static constexpr std::wstring_view value{ L"SessionLocateHash"sv }; };
        using property_type = int32_t;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ISessionStatus;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.SessionLocateHash();
            }
        };
    };
    struct UserFeedback
    {
        struct name { static constexpr std::wstring_view value{ L"UserFeedback"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::SessionUserFeedback;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ISessionStatus;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.UserFeedback();
            }
        };
    };};
    struct list { using type = impl::typelist<named::ReadyForCreateProgress, named::RecommendedForCreateProgress, named::SessionCreateHash, named::SessionLocateHash, named::UserFeedback>; };
};

struct property_Microsoft_Azure_SpatialAnchors_ISessionUpdatedEventArgs
{ struct named {
    struct Status
    {
        struct name { static constexpr std::wstring_view value{ L"Status"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::SessionStatus;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ISessionUpdatedEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Status();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Status>; };
};

struct property_Microsoft_Azure_SpatialAnchors_ITokenRequiredEventArgs
{ struct named {
    struct AccessToken
    {
        struct name { static constexpr std::wstring_view value{ L"AccessToken"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.AccessToken();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.AccessToken(std::forward<Value>(value));
            }
        };
    };
    struct AuthenticationToken
    {
        struct name { static constexpr std::wstring_view value{ L"AuthenticationToken"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.AuthenticationToken();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.AuthenticationToken(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::AccessToken, named::AuthenticationToken>; };
};

struct property_Microsoft_Azure_SpatialAnchors_AnchorLocateCriteria
{ struct named {
    struct Strategy
    {
        struct name { static constexpr std::wstring_view value{ L"Strategy"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::LocateStrategy;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Strategy();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.Strategy(std::forward<Value>(value));
            }
        };
    };
    struct RequestedCategories
    {
        struct name { static constexpr std::wstring_view value{ L"RequestedCategories"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::AnchorDataCategory;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.RequestedCategories();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.RequestedCategories(std::forward<Value>(value));
            }
        };
    };
    struct NearAnchor
    {
        struct name { static constexpr std::wstring_view value{ L"NearAnchor"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::NearAnchorCriteria;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.NearAnchor();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.NearAnchor(std::forward<Value>(value));
            }
        };
    };
    struct Identifiers
    {
        struct name { static constexpr std::wstring_view value{ L"Identifiers"sv }; };
        using property_type = com_array<hstring>;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Identifiers();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.Identifiers(std::forward<Value>(value));
            }
        };
    };
    struct BypassCache
    {
        struct name { static constexpr std::wstring_view value{ L"BypassCache"sv }; };
        using property_type = bool;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.BypassCache();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.BypassCache(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::Strategy, named::RequestedCategories, named::NearAnchor, named::Identifiers, named::BypassCache>; };
};

struct property_Microsoft_Azure_SpatialAnchors_AnchorLocatedEventArgs
{ struct named {
    struct Anchor
    {
        struct name { static constexpr std::wstring_view value{ L"Anchor"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::AnchorLocatedEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Anchor();
            }
        };
    };
    struct Identifier
    {
        struct name { static constexpr std::wstring_view value{ L"Identifier"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::AnchorLocatedEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Identifier();
            }
        };
    };
    struct Status
    {
        struct name { static constexpr std::wstring_view value{ L"Status"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::LocateAnchorStatus;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::AnchorLocatedEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Status();
            }
        };
    };
    struct Watcher
    {
        struct name { static constexpr std::wstring_view value{ L"Watcher"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::AnchorLocatedEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Watcher();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Anchor, named::Identifier, named::Status, named::Watcher>; };
};

struct property_Microsoft_Azure_SpatialAnchors_CloudSpatialAnchor
{ struct named {
    struct LocalAnchor
    {
        struct name { static constexpr std::wstring_view value{ L"LocalAnchor"sv }; };
        using property_type = winrt::Windows::Perception::Spatial::SpatialAnchor;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.LocalAnchor();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.LocalAnchor(std::forward<Value>(value));
            }
        };
    };
    struct Expiration
    {
        struct name { static constexpr std::wstring_view value{ L"Expiration"sv }; };
        using property_type = winrt::Windows::Foundation::DateTime;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Expiration();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.Expiration(std::forward<Value>(value));
            }
        };
    };
    struct AppProperties
    {
        struct name { static constexpr std::wstring_view value{ L"AppProperties"sv }; };
        using property_type = winrt::Windows::Foundation::Collections::IMap<hstring, hstring>;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.AppProperties();
            }
        };
    };
    struct Identifier
    {
        struct name { static constexpr std::wstring_view value{ L"Identifier"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Identifier();
            }
        };
    };
    struct VersionTag
    {
        struct name { static constexpr std::wstring_view value{ L"VersionTag"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.VersionTag();
            }
        };
    };};
    struct list { using type = impl::typelist<named::LocalAnchor, named::Expiration, named::AppProperties, named::Identifier, named::VersionTag>; };
};

struct property_Microsoft_Azure_SpatialAnchors_CloudSpatialAnchorSession
{ struct named {
    struct LogLevel
    {
        struct name { static constexpr std::wstring_view value{ L"LogLevel"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::SessionLogLevel;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSession;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.LogLevel();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.LogLevel(std::forward<Value>(value));
            }
        };
    };
    struct Configuration
    {
        struct name { static constexpr std::wstring_view value{ L"Configuration"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::SessionConfiguration;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSession;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Configuration();
            }
        };
    };
    struct Diagnostics
    {
        struct name { static constexpr std::wstring_view value{ L"Diagnostics"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSession;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Diagnostics();
            }
        };
    };
    struct SessionId
    {
        struct name { static constexpr std::wstring_view value{ L"SessionId"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSession;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.SessionId();
            }
        };
    };};
    struct list { using type = impl::typelist<named::LogLevel, named::Configuration, named::Diagnostics, named::SessionId>; };
};

struct property_Microsoft_Azure_SpatialAnchors_CloudSpatialAnchorSessionDiagnostics
{ struct named {
    struct MaxDiskSizeInMB
    {
        struct name { static constexpr std::wstring_view value{ L"MaxDiskSizeInMB"sv }; };
        using property_type = int32_t;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.MaxDiskSizeInMB();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.MaxDiskSizeInMB(std::forward<Value>(value));
            }
        };
    };
    struct LogLevel
    {
        struct name { static constexpr std::wstring_view value{ L"LogLevel"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::SessionLogLevel;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.LogLevel();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.LogLevel(std::forward<Value>(value));
            }
        };
    };
    struct LogDirectory
    {
        struct name { static constexpr std::wstring_view value{ L"LogDirectory"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.LogDirectory();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.LogDirectory(std::forward<Value>(value));
            }
        };
    };
    struct ImagesEnabled
    {
        struct name { static constexpr std::wstring_view value{ L"ImagesEnabled"sv }; };
        using property_type = bool;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ImagesEnabled();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ImagesEnabled(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::MaxDiskSizeInMB, named::LogLevel, named::LogDirectory, named::ImagesEnabled>; };
};

struct property_Microsoft_Azure_SpatialAnchors_CloudSpatialAnchorWatcher
{ struct named {
    struct Identifier
    {
        struct name { static constexpr std::wstring_view value{ L"Identifier"sv }; };
        using property_type = int32_t;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Identifier();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Identifier>; };
};

struct property_Microsoft_Azure_SpatialAnchors_LocateAnchorsCompletedEventArgs
{ struct named {
    struct Cancelled
    {
        struct name { static constexpr std::wstring_view value{ L"Cancelled"sv }; };
        using property_type = bool;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Cancelled();
            }
        };
    };
    struct Watcher
    {
        struct name { static constexpr std::wstring_view value{ L"Watcher"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Watcher();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Cancelled, named::Watcher>; };
};

struct property_Microsoft_Azure_SpatialAnchors_NearAnchorCriteria
{ struct named {
    struct SourceAnchor
    {
        struct name { static constexpr std::wstring_view value{ L"SourceAnchor"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::NearAnchorCriteria;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.SourceAnchor();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.SourceAnchor(std::forward<Value>(value));
            }
        };
    };
    struct MaxResultCount
    {
        struct name { static constexpr std::wstring_view value{ L"MaxResultCount"sv }; };
        using property_type = int32_t;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::NearAnchorCriteria;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.MaxResultCount();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.MaxResultCount(std::forward<Value>(value));
            }
        };
    };
    struct DistanceInMeters
    {
        struct name { static constexpr std::wstring_view value{ L"DistanceInMeters"sv }; };
        using property_type = float;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::NearAnchorCriteria;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.DistanceInMeters();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.DistanceInMeters(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::SourceAnchor, named::MaxResultCount, named::DistanceInMeters>; };
};

struct property_Microsoft_Azure_SpatialAnchors_OnLogDebugEventArgs
{ struct named {
    struct Message
    {
        struct name { static constexpr std::wstring_view value{ L"Message"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::OnLogDebugEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Message();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Message>; };
};

struct property_Microsoft_Azure_SpatialAnchors_SessionConfiguration
{ struct named {
    struct AuthenticationToken
    {
        struct name { static constexpr std::wstring_view value{ L"AuthenticationToken"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::SessionConfiguration;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.AuthenticationToken();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.AuthenticationToken(std::forward<Value>(value));
            }
        };
    };
    struct AccountKey
    {
        struct name { static constexpr std::wstring_view value{ L"AccountKey"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::SessionConfiguration;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.AccountKey();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.AccountKey(std::forward<Value>(value));
            }
        };
    };
    struct AccountId
    {
        struct name { static constexpr std::wstring_view value{ L"AccountId"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::SessionConfiguration;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.AccountId();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.AccountId(std::forward<Value>(value));
            }
        };
    };
    struct AccountDomain
    {
        struct name { static constexpr std::wstring_view value{ L"AccountDomain"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::SessionConfiguration;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.AccountDomain();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.AccountDomain(std::forward<Value>(value));
            }
        };
    };
    struct AccessToken
    {
        struct name { static constexpr std::wstring_view value{ L"AccessToken"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::SessionConfiguration;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.AccessToken();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.AccessToken(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::AuthenticationToken, named::AccountKey, named::AccountId, named::AccountDomain, named::AccessToken>; };
};

struct property_Microsoft_Azure_SpatialAnchors_SessionErrorEventArgs
{ struct named {
    struct ErrorCode
    {
        struct name { static constexpr std::wstring_view value{ L"ErrorCode"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::SessionErrorEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ErrorCode();
            }
        };
    };
    struct ErrorMessage
    {
        struct name { static constexpr std::wstring_view value{ L"ErrorMessage"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::SessionErrorEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ErrorMessage();
            }
        };
    };
    struct Watcher
    {
        struct name { static constexpr std::wstring_view value{ L"Watcher"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::SessionErrorEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Watcher();
            }
        };
    };};
    struct list { using type = impl::typelist<named::ErrorCode, named::ErrorMessage, named::Watcher>; };
};

struct property_Microsoft_Azure_SpatialAnchors_SessionStatus
{ struct named {
    struct ReadyForCreateProgress
    {
        struct name { static constexpr std::wstring_view value{ L"ReadyForCreateProgress"sv }; };
        using property_type = float;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::SessionStatus;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ReadyForCreateProgress();
            }
        };
    };
    struct RecommendedForCreateProgress
    {
        struct name { static constexpr std::wstring_view value{ L"RecommendedForCreateProgress"sv }; };
        using property_type = float;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::SessionStatus;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.RecommendedForCreateProgress();
            }
        };
    };
    struct SessionCreateHash
    {
        struct name { static constexpr std::wstring_view value{ L"SessionCreateHash"sv }; };
        using property_type = int32_t;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::SessionStatus;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.SessionCreateHash();
            }
        };
    };
    struct SessionLocateHash
    {
        struct name { static constexpr std::wstring_view value{ L"SessionLocateHash"sv }; };
        using property_type = int32_t;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::SessionStatus;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.SessionLocateHash();
            }
        };
    };
    struct UserFeedback
    {
        struct name { static constexpr std::wstring_view value{ L"UserFeedback"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::SessionUserFeedback;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::SessionStatus;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.UserFeedback();
            }
        };
    };};
    struct list { using type = impl::typelist<named::ReadyForCreateProgress, named::RecommendedForCreateProgress, named::SessionCreateHash, named::SessionLocateHash, named::UserFeedback>; };
};

struct property_Microsoft_Azure_SpatialAnchors_SessionUpdatedEventArgs
{ struct named {
    struct Status
    {
        struct name { static constexpr std::wstring_view value{ L"Status"sv }; };
        using property_type = winrt::Microsoft::Azure::SpatialAnchors::SessionStatus;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::SessionUpdatedEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Status();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Status>; };
};

struct property_Microsoft_Azure_SpatialAnchors_TokenRequiredEventArgs
{ struct named {
    struct AuthenticationToken
    {
        struct name { static constexpr std::wstring_view value{ L"AuthenticationToken"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::TokenRequiredEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.AuthenticationToken();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.AuthenticationToken(std::forward<Value>(value));
            }
        };
    };
    struct AccessToken
    {
        struct name { static constexpr std::wstring_view value{ L"AccessToken"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::Microsoft::Azure::SpatialAnchors::TokenRequiredEventArgs;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.AccessToken();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.AccessToken(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::AuthenticationToken, named::AccessToken>; };
};

}

WINRT_EXPORT namespace winrt::experimental::reflect {
template <> struct named_property<Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria> : impl::property_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria> : impl::property_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_IAnchorLocatedEventArgs::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_IAnchorLocatedEventArgs::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor> : impl::property_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor> : impl::property_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession> : impl::property_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession> : impl::property_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics> : impl::property_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics> : impl::property_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorWatcher> : impl::property_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorWatcher::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorWatcher> : impl::property_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorWatcher::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::ILocateAnchorsCompletedEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_ILocateAnchorsCompletedEventArgs::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::ILocateAnchorsCompletedEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_ILocateAnchorsCompletedEventArgs::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::INearAnchorCriteria> : impl::property_Microsoft_Azure_SpatialAnchors_INearAnchorCriteria::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::INearAnchorCriteria> : impl::property_Microsoft_Azure_SpatialAnchors_INearAnchorCriteria::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::IOnLogDebugEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_IOnLogDebugEventArgs::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::IOnLogDebugEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_IOnLogDebugEventArgs::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::ISessionConfiguration> : impl::property_Microsoft_Azure_SpatialAnchors_ISessionConfiguration::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::ISessionConfiguration> : impl::property_Microsoft_Azure_SpatialAnchors_ISessionConfiguration::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_ISessionErrorEventArgs::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_ISessionErrorEventArgs::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::ISessionStatus> : impl::property_Microsoft_Azure_SpatialAnchors_ISessionStatus::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::ISessionStatus> : impl::property_Microsoft_Azure_SpatialAnchors_ISessionStatus::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::ISessionUpdatedEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_ISessionUpdatedEventArgs::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::ISessionUpdatedEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_ISessionUpdatedEventArgs::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_ITokenRequiredEventArgs::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_ITokenRequiredEventArgs::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria> : impl::property_Microsoft_Azure_SpatialAnchors_AnchorLocateCriteria::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria> : impl::property_Microsoft_Azure_SpatialAnchors_AnchorLocateCriteria::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::AnchorLocatedEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_AnchorLocatedEventArgs::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::AnchorLocatedEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_AnchorLocatedEventArgs::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor> : impl::property_Microsoft_Azure_SpatialAnchors_CloudSpatialAnchor::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor> : impl::property_Microsoft_Azure_SpatialAnchors_CloudSpatialAnchor::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSession> : impl::property_Microsoft_Azure_SpatialAnchors_CloudSpatialAnchorSession::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSession> : impl::property_Microsoft_Azure_SpatialAnchors_CloudSpatialAnchorSession::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics> : impl::property_Microsoft_Azure_SpatialAnchors_CloudSpatialAnchorSessionDiagnostics::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics> : impl::property_Microsoft_Azure_SpatialAnchors_CloudSpatialAnchorSessionDiagnostics::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher> : impl::property_Microsoft_Azure_SpatialAnchors_CloudSpatialAnchorWatcher::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher> : impl::property_Microsoft_Azure_SpatialAnchors_CloudSpatialAnchorWatcher::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_LocateAnchorsCompletedEventArgs::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_LocateAnchorsCompletedEventArgs::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::NearAnchorCriteria> : impl::property_Microsoft_Azure_SpatialAnchors_NearAnchorCriteria::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::NearAnchorCriteria> : impl::property_Microsoft_Azure_SpatialAnchors_NearAnchorCriteria::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::OnLogDebugEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_OnLogDebugEventArgs::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::OnLogDebugEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_OnLogDebugEventArgs::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::SessionConfiguration> : impl::property_Microsoft_Azure_SpatialAnchors_SessionConfiguration::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::SessionConfiguration> : impl::property_Microsoft_Azure_SpatialAnchors_SessionConfiguration::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::SessionErrorEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_SessionErrorEventArgs::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::SessionErrorEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_SessionErrorEventArgs::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::SessionStatus> : impl::property_Microsoft_Azure_SpatialAnchors_SessionStatus::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::SessionStatus> : impl::property_Microsoft_Azure_SpatialAnchors_SessionStatus::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::SessionUpdatedEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_SessionUpdatedEventArgs::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::SessionUpdatedEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_SessionUpdatedEventArgs::list {};
template <> struct named_property<Microsoft::Azure::SpatialAnchors::TokenRequiredEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_TokenRequiredEventArgs::named {};
template <> struct properties<Microsoft::Azure::SpatialAnchors::TokenRequiredEventArgs> : impl::property_Microsoft_Azure_SpatialAnchors_TokenRequiredEventArgs::list {};
template <> struct get_enumerator_names<Microsoft::Azure::SpatialAnchors::AnchorDataCategory>
{
    static constexpr std::array<std::wstring_view, 3> value{{ 
        {L"None", 4},
        {L"Properties", 10},
        {L"Spatial", 7}, }};
};
template <> struct get_enumerator_values<Microsoft::Azure::SpatialAnchors::AnchorDataCategory>
{
    static constexpr std::array<Microsoft::Azure::SpatialAnchors::AnchorDataCategory, 3> value{{ 
        Microsoft::Azure::SpatialAnchors::AnchorDataCategory::None,
        Microsoft::Azure::SpatialAnchors::AnchorDataCategory::Properties,
        Microsoft::Azure::SpatialAnchors::AnchorDataCategory::Spatial, }};
};
template <> struct get_enumerator_names<Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode>
{
    static constexpr std::array<std::wstring_view, 19> value{{ 
        {L"MetadataTooLarge", 16},
        {L"ApplicationNotAuthenticated", 27},
        {L"ApplicationNotAuthorized", 24},
        {L"ConcurrencyViolation", 20},
        {L"NotEnoughSpatialData", 20},
        {L"NoSpatialLocationHint", 21},
        {L"CannotConnectToServer", 21},
        {L"ServerError", 11},
        {L"AlreadyAssociatedWithADifferentStore", 36},
        {L"AlreadyExists", 13},
        {L"NoLocateCriteriaSpecified", 25},
        {L"NoAccessTokenSpecified", 22},
        {L"UnableToObtainAccessToken", 25},
        {L"TooManyRequests", 15},
        {L"LocateCriteriaMissingRequiredValues", 35},
        {L"LocateCriteriaInConflict", 24},
        {L"LocateCriteriaInvalid", 21},
        {L"LocateCriteriaNotSupported", 26},
        {L"Unknown", 7}, }};
};
template <> struct get_enumerator_values<Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode>
{
    static constexpr std::array<Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode, 19> value{{ 
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::MetadataTooLarge,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::ApplicationNotAuthenticated,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::ApplicationNotAuthorized,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::ConcurrencyViolation,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::NotEnoughSpatialData,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::NoSpatialLocationHint,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::CannotConnectToServer,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::ServerError,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::AlreadyAssociatedWithADifferentStore,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::AlreadyExists,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::NoLocateCriteriaSpecified,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::NoAccessTokenSpecified,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::UnableToObtainAccessToken,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::TooManyRequests,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::LocateCriteriaMissingRequiredValues,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::LocateCriteriaInConflict,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::LocateCriteriaInvalid,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::LocateCriteriaNotSupported,
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode::Unknown, }};
};
template <> struct get_enumerator_names<Microsoft::Azure::SpatialAnchors::LocateAnchorStatus>
{
    static constexpr std::array<std::wstring_view, 4> value{{ 
        {L"AlreadyTracked", 14},
        {L"Located", 7},
        {L"NotLocated", 10},
        {L"NotLocatedAnchorDoesNotExist", 28}, }};
};
template <> struct get_enumerator_values<Microsoft::Azure::SpatialAnchors::LocateAnchorStatus>
{
    static constexpr std::array<Microsoft::Azure::SpatialAnchors::LocateAnchorStatus, 4> value{{ 
        Microsoft::Azure::SpatialAnchors::LocateAnchorStatus::AlreadyTracked,
        Microsoft::Azure::SpatialAnchors::LocateAnchorStatus::Located,
        Microsoft::Azure::SpatialAnchors::LocateAnchorStatus::NotLocated,
        Microsoft::Azure::SpatialAnchors::LocateAnchorStatus::NotLocatedAnchorDoesNotExist, }};
};
template <> struct get_enumerator_names<Microsoft::Azure::SpatialAnchors::LocateStrategy>
{
    static constexpr std::array<std::wstring_view, 3> value{{ 
        {L"AnyStrategy", 11},
        {L"VisualInformation", 17},
        {L"Relationship", 12}, }};
};
template <> struct get_enumerator_values<Microsoft::Azure::SpatialAnchors::LocateStrategy>
{
    static constexpr std::array<Microsoft::Azure::SpatialAnchors::LocateStrategy, 3> value{{ 
        Microsoft::Azure::SpatialAnchors::LocateStrategy::AnyStrategy,
        Microsoft::Azure::SpatialAnchors::LocateStrategy::VisualInformation,
        Microsoft::Azure::SpatialAnchors::LocateStrategy::Relationship, }};
};
template <> struct get_enumerator_names<Microsoft::Azure::SpatialAnchors::SessionLogLevel>
{
    static constexpr std::array<std::wstring_view, 6> value{{ 
        {L"None", 4},
        {L"Error", 5},
        {L"Warning", 7},
        {L"Information", 11},
        {L"Debug", 5},
        {L"All", 3}, }};
};
template <> struct get_enumerator_values<Microsoft::Azure::SpatialAnchors::SessionLogLevel>
{
    static constexpr std::array<Microsoft::Azure::SpatialAnchors::SessionLogLevel, 6> value{{ 
        Microsoft::Azure::SpatialAnchors::SessionLogLevel::None,
        Microsoft::Azure::SpatialAnchors::SessionLogLevel::Error,
        Microsoft::Azure::SpatialAnchors::SessionLogLevel::Warning,
        Microsoft::Azure::SpatialAnchors::SessionLogLevel::Information,
        Microsoft::Azure::SpatialAnchors::SessionLogLevel::Debug,
        Microsoft::Azure::SpatialAnchors::SessionLogLevel::All, }};
};
template <> struct get_enumerator_names<Microsoft::Azure::SpatialAnchors::SessionUserFeedback>
{
    static constexpr std::array<std::wstring_view, 4> value{{ 
        {L"None", 4},
        {L"NotEnoughMotion", 15},
        {L"MotionTooQuick", 14},
        {L"NotEnoughFeatures", 17}, }};
};
template <> struct get_enumerator_values<Microsoft::Azure::SpatialAnchors::SessionUserFeedback>
{
    static constexpr std::array<Microsoft::Azure::SpatialAnchors::SessionUserFeedback, 4> value{{ 
        Microsoft::Azure::SpatialAnchors::SessionUserFeedback::None,
        Microsoft::Azure::SpatialAnchors::SessionUserFeedback::NotEnoughMotion,
        Microsoft::Azure::SpatialAnchors::SessionUserFeedback::MotionTooQuick,
        Microsoft::Azure::SpatialAnchors::SessionUserFeedback::NotEnoughFeatures, }};
};

}

WINRT_EXPORT namespace std {

template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDeferral> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDeferral> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorWatcher> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorWatcher> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ILocateAnchorsCompletedEventArgs> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::ILocateAnchorsCompletedEventArgs> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::INearAnchorCriteria> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::INearAnchorCriteria> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::IOnLogDebugEventArgs> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::IOnLogDebugEventArgs> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ISessionConfiguration> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::ISessionConfiguration> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ISessionStatus> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::ISessionStatus> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ISessionUpdatedEventArgs> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::ISessionUpdatedEventArgs> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ISpatialAnchorsFactory> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::ISpatialAnchorsFactory> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::AnchorLocatedEventArgs> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::AnchorLocatedEventArgs> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSession> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSession> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDeferral> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDeferral> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedEventArgs> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedEventArgs> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::NearAnchorCriteria> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::NearAnchorCriteria> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::OnLogDebugEventArgs> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::OnLogDebugEventArgs> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::SessionConfiguration> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::SessionConfiguration> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::SessionErrorEventArgs> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::SessionErrorEventArgs> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::SessionStatus> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::SessionStatus> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::SessionUpdatedEventArgs> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::SessionUpdatedEventArgs> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::SpatialAnchorsFactory> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::SpatialAnchorsFactory> {};
template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::TokenRequiredEventArgs> : winrt::impl::hash_base<winrt::Microsoft::Azure::SpatialAnchors::TokenRequiredEventArgs> {};

}
